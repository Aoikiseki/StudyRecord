## 识字

1. 视频播放页左上角标注当前学习的字（见UI稿）
2. 首页单元卡片阴影



### 加下方二维码

```swift
func generateQRSnapshot() -> UIImage? {
    guard let snapshot = generateSnapshot(),
    ImageUtils.isImageValid(snapshot) else { return nil }
    let qrCodeViewSize = CGSize(width: snapshot.size.width, height: 82.0)
    let qrCodeCell = ShareLogoCell(frame: .init(origin: .zero, size: qrCodeViewSize))
    qrCodeCell.bindData(with: .init(qrCodeImage: UIImage(named: "finish_share_QR")))
    let qrCodeViewImage = qrCodeCell.leo.snapshot()

    UIGraphicsBeginImageContextWithOptions(.init(width: snapshot.size.width, height: snapshot.size.height + qrCodeViewSize.height), false, UIScreen.main.scale)
    defer { UIGraphicsEndImageContext() }
    snapshot.draw(in: .init(origin: .zero, size: snapshot.size))
    qrCodeViewImage?.draw(in: .init(origin: .init(x: 0, y: snapshot.size.height), size: qrCodeViewSize))
    return UIGraphicsGetImageFromCurrentImageContext()
}
```




anchorPoint、position、frame

https://www.cnblogs.com/Free-Thinker/p/11269662.html



### presentingViewController、presentedViewController

A present B **modally**：

- 则B.presentingViewController == A，如果B没有被A present modally，但是B的某个祖先被present modally，则该属性被赋为展示该祖先的VC，否则为nil
- 则A.presentedViewController == B

项目中的例子：popOrDismiss

```swift
(BOOL)isPresentedViewController:(UIViewController *)viewController {
    // 1. VC1(presenting) -> VC2(presented, end) => VC2 is presented
    BOOL isPresented = viewController.presentingViewController.presentedViewController == viewController;

    // 2. VC1(presenting) -> VC2(presented, UINavigationController) ~> VC3(pushed, end)  => VC2 and VC3 is presented
    if (viewController.navigationController != nil &&
        (viewController == viewController.navigationController.viewControllers[0] ||
         viewController.parentViewController == viewController.navigationController.viewControllers[0])) {
        isPresented |= viewController.presentingViewController.presentedViewController == viewController.navigationController;
    }

    // NOTE: 场景3和4暂无需求，不判断了
    // 3. VC1(presenting) -> VC2(presented, UITabBarController) ~> VC3(UINavigationController) ~> VC4(pushed, end)  => VC2, VC3 and VC4 is presented
    // 4. VC1(presenting) -> VC2(presented, UITabBarController) ~> VC3(end) => VC2 and VC3 is presented
    return isPresented;
}
```



### removeAllAnimation在iOS12和iOS10等老版本系统上的坑？

### 小车页面底部图片

### 列表页底部图片

### Banner渲染逻辑

Banner通过Firework进行渲染，`FireworkBannerItemLoader`负责为BannerView提供数据

### FireworkBannerItemLoader结构

- BannerItem：Banner的基本单元

  ```swift
  public let id: Int
  public let imageURL: String
  public let secondImageURL: String?
  public let jumpURL: String
  public let customExt: String?
  public let priority: Double
  ```

- position & page

  通过在`ActivityPageConstants`中定义的position和page来得到当前Loader应该加载的数据

  ```swift
  private let position: String
  private let page: String
  ```

- func getDefaultBannerItems()

  为指定page、position的页面提供默认Banner，目前只为MainIcon&MainBanner和MainNormal&MainBanner两种组合提供默认值

- func reloadData(with viewModel: BannerViewModel?)

  `BannerViewModel`提供imageURL，使用`SDWebImageManager`尝试将所有图片加载进缓存，当全部图片都可以被成功加载后更新Loader持有的`bannerItems`

- func start()

  Loader创建出来后立刻在init中被调用

  ```swift
  public func start() {
    	FireworkManager.shared.register(banner: self, needRefreshBanner: true)
  }
  ```

  FireworkManager中使用banners变量存储所有已注册的banner，使用viewModels存储所有已注册的bannerViewModel，register会更新数组中指定position&page组合的banner，并尝试获取该position的bannerViewModel，调用上面的reloadData方法更新bannerItems：

  ```swift
  public func register(banner: BannerType, needRefreshBanner: Bool) {
      for (index, b) in banners.enumerated() {
          if b.positionID == banner.positionID, b.pageID == banner.pageID  {
              banners[index] = banner
              if let viewModel = bannerViewModel(with: banner.positionID) {
                banner.reloadData(with: viewModel)
              }
            	return
          }
      }
      if needRefreshBanner {
        	banners.append(banner)
      }
      if let viewModel = bannerViewModel(with: banner.positionID) {
        	banner.reloadData(with: viewModel)
      }
  }
  ```

### CarouselBannerView结构

- bannerItemsLoader: FireworkBannerItemLoader 
- bannerItems: [BannerItem] //包含banner渲染必备的信息，比如imageURL
- carouselView: CarouselView //真正用来展示banner的View

在setupActions中监听bannerItemsLoader.bannerItems的变化，赋值给自己的bannerItems，通过delegate和dataSource给carouseView提供数据和事件响应

### CarouselView结构

展示Banner图片的View，包括scrollView和pageControl，主要有两部分，一是用Timer和scrollView控制Banner的轮转；二是在reloadData中通过dataSourceDelegate为提供具体的数据即UIView（ImageView），并添加进scrollView

### HomePageBannerCell

